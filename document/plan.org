#+DATE: <2019-07-11 四>
#+STARTUP: SHOWALL
#+TAGS: lammps, sw

* 工作进度

** TODO 基本运行
*** TODO 主核版本
    DEADLINE: <2019-07-11 四>
**** DONE 构建,并给出编译问题
      CLOSED: [2019-07-11 四 10:20]

***** DONE 构建版本
       CLOSED: [2019-07-11 四 10:12] DEADLINE: <2019-07-11 四 10:05>
       - [X] source tree
       - [X] src
       - [X] lmp, makefile
       - makefile.sunway 中的 LIB 不需要
       - src 不要放两个
      

***** DONE 编译
       CLOSED: [2019-07-11 四 10:12] DEADLINE: <2019-07-11 四 10:15>
**** DONE 编译错误 [3/3]
      CLOSED: [2019-07-11 四 15:02]
***** DONE reduce 中寄存器通信的使用
       CLOSED: [2019-07-11 四 14:37] DEADLINE: <2019-07-11 四 10:40>
       - [X] 更改函数定义与调用
       - [X] 更改调用参数
	 + 第二个参数是指归约的数据个数, 如果是 2 的话就是在所有的核上对两个数据同时进行归约
***** DONE athread 的使用
       CLOSED: [2019-07-11 四 15:02] DEADLINE: <2019-07-11 四 10:55>
****** DONE SYNC 链接错误
	 CLOSED: [2019-07-11 四 15:02]
****** DONE athread 链接错误
	 CLOSED: [2019-07-11 四 15:02]
	- [X] 更改 makefile, 将出现错误信息的链接去掉

***** DONE 向量化 doublev4
       CLOSED: [2019-07-11 四 11:26] DEADLINE: <2019-07-11 四 11:20>

**** TODO 运行时错误
***** TODO inline 浮点错误 [4/6]
      错误位置与之前相同
****** DONE 换非 eff 样例
       CLOSED: [2019-07-11 四 15:26] DEADLINE: <2019-07-11 四 15:20>
       不知道是否是没有包的原因, 总是报出以下两种错误
       - 
****** DONE 换官方 eff 样例
       CLOSED: [2019-07-11 四 15:27] DEADLINE: <2019-07-11 四 15:30>
       成功运行
****** DONE 使用原版运行官方 eff 样例
       CLOSED: [2019-07-11 四 15:47] DEADLINE: <2019-07-11 四 15:40>
       依旧报错, 这里先不深究
****** DONE 换另一组自己的样例
       CLOSED: [2019-07-11 四 15:47] DEADLINE: <2019-07-11 四 15:40>
       依旧报错
****** TODO 多测试几组官方 eff 样例
       DEADLINE: <2019-07-11 四 16:10>
       - Auger      :: inline252
       - Be         :: inline441
       - CH4        :: ok
       - ECP        :: ok
       - fixed-core :: ok
       - H          :: ok
       - H2         :: ok
       - H_plasma   :: none
       - Li-den     :: abort and ok
       - Li-solid   :: inline252 and cpp251
**** TODO 分析报错原因
     在错误的位置对错误的值在非错误的样例中进行调试
       - [X] 之前几组例子不报错可能是由于数据量小, 导致不会产生错误
***** 每次测试的错误位置相同吗, 或者在不同数量核组的计算中错误位置相同吗
      - x  :: 731.780789
      - rc :: 6.989871
      - 超过一个核组时如果进行打印将会卡死
      - 换变量进行输出
	- 依然卡死
***** 不同组的错误位置相同吗
      - 第一组
	rc :: 7.097805
	x  :: 735.994758
      - 第二组
        同上个子项
      - 第三组
        rc :: 7.083218
***** 不同组的数据有区别吗
      数据不同
***** TODO 注释掉输出语句, 直接计算值是否可行
      DEADLINE: <2019-07-11 四 19:35>
      - 在最后一条语句时会出现异常
      - 在注释掉所有值后异常会转移到调用外
***** 报错位置在什么时候不一致
      DEADLINE: <2019-07-11 四 19:55>
      
****** 不同样例 & 不同节点
       - 1.1->1.8 :: 261
       - 2 :: 261
****** 不同调试语句
       - 加入三个调试打印语句后变为 249
       - 去掉后变为 257
       - 再加两个同文件依然 257
       - 这次只加一个变为 251
       - 将 ipoly 分开后变为 264
       - 不用调试 252
       - printf251
       - fprintf251
       - 两个 fprintf251
****** TODO 只加入调试打印语句后为什么产生异常的语句改变
       - 调试语句本身的问题


***** DONE 不同组数据报错的步数一定吗
      CLOSED: [2019-07-12 五 08:52] DEADLINE: <2019-07-12 五 08:50>
      - 1 :: 389-443
      - 2 :: 1585-1627
      - 3 :: 2787-2819
****** DONE 给出步骤断点
       CLOSED: [2019-07-12 五 08:52] DEADLINE: <2019-07-12 五 08:40>
****** DONE 三个样例调试
       CLOSED: [2019-07-12 五 08:52] DEADLINE: <2019-07-12 五 08:30>
       - 如果相同则再调试官方例子
pp
***** DONE 定位具体数据位置
      CLOSED: [2019-07-12 五 10:46]
      - 打印坐标值, 位于 799 行
      - 数据替换后, 却会在之前产生错误

***** 几列含义
      | id | type     | q      | spin | eradius | x | y | z |
      |----+----------+--------+------+---------+---+---+---|
      |    | 粒子类型 | 电子量 | 自旋 | 半径    |   |   |   |

***** DONE 类型的问题导致错误
      CLOSED: [2019-07-12 五 15:01]
      - 799, 800
      - 3171, 3200
      - 12739, 12800
	
***** TODO 如何对类型错误进行排除
****** TODO 看不同类型中在程序中对值的影响
       DEADLINE: <2019-07-12 五 >

******* TODO 该粒子在报错之前, 是否被调用运行过
	如果在运行之前就已经报错, 可考虑是否只在两个特殊类型粒子进行计算才会产生异常
	一般来说, 异常产生的位置可进行错误定位, 但报错的位置并不一定时计算出问题的位置

******* TODO 格式化输出
	- [X] 两个粒子的特征
	  - 两类粒子的坐标值
	    一般来说, 如果数据不进行重复, 那么只打印粒子的坐标即可出粒子
	  - 粒子的 type 值
******* TODO 原因分析
	- [X] 由于粒子类型而引起的错误 :: 排除
	- [] 由于坐标的正负值导致
	  - 1/2/3: x 由负值转正值
	  - 

******* TODO 数据
	- 1 1.0 0 0.0 -> 2 3.0 0    0.0
	- 1 1.0 0 0.0 -> 2 0.0 1/-1 1.8

****** TODO 通过对其他有相同异常问题的样例进行运行
       DEADLINE: <2019-07-12 五 15:15>
       - [X] Li.ang :: 在第一个位置即出错(此样例重复数据较多, 可能不能代表)
       - [X] Au     :: 找不到出错数据

****** TODO 找到三个样例发生异常数据的共同之处

****** TODO 找到可能出现异常的位置
******* TODO 分组调试
	- 可能是 x 过小, exp_term 过大
	- f 同样会打印
	- recip 的计算同样不会报错
	- 判断 f 与 recip_x 是否是一个值
	  二者值经测试相等
	- exp_term 的值未进行替换
	- 是否是最后对 df 的计算报错
	- printf 中计算的值与语句中是否由区别

	- # 只打印基本操作 recip, 错误会发生在 c3, 但是打印正常
	- 只打印 f -- c1, 无法打印
	- 只打印 expterm -- c2 :: 0, 但事实上小数点后是否为 0 为止
	- 只打印 ipoly -- c2 打印正常
	- 只打印 recip -- c1, 打印正常 
	- 打印上述三个值 --  c3, 打印正常
	- 打印 div -- 直接在打印位置报错, 无法打印
	- 同时打印 recip 与 f --
	- 不进行打印, -- c2
	- c1 :: 计算 t
	- c2 :: 计算 recip
	- c3 :: 计算 f
	- c4 :: 写 df
******* TODO 分析
	首先基本可以排除 ipoly 的问题
	一般来说, 如果打印语句与计算语句相一致, 那么无法打印也就是意味着该语句运行异常
	- [X] 从打印情况入手
	  共有两个打印异常, 打印 f 与 div, 其中 div 为 f 的子句, 也就是可能是 div 引起的 f 错误
	  可能错误, 过小/过大, 其中 x2 正常, 也就是说该 expterm 过小
	  原因: 虽然 exp 后会有比报错值更小的值, 但当值过小时, 就会直接赋 0, 当这个位置不会
	- 从打印位置入手

******* DONE 解决办法
	 CLOSED: [2019-07-13 六 17:20]
	给一个固定的值, 这个值为产生异常的阈值

***** 浮点异常
      
	
***** TODO 利用__LINE__如何调试

***** TODO lj 的样例会出现问题吗
      - 利用所给的样例, 不然会提示 newton_pair 的问题

***** 其他样例
      测试 lj 样例时, 在使用多个核组时会出现错误
      - duplicate atom IDs exist
      - unknown command: compute_style
***** DONE 查询常见的浮点异常
      CLOSED: [2019-07-12 五 10:46]
      -无效操作
      - 除 0
      - 上溢
      - 下溢
***** TODO 是否是浮点上溢导致浮点异常
      错误位置不确定, 所以也就无法确定异常原因

***** TODO 参考 lj 的方法
      可能主核本身跑通就有问题
      - 但对异常的解决没有什么参照

***** TODO th 上纯主核版本运行非 eff 样例的情况


***** DONE 用 GDB 进行调试
      CLOSED: [2019-07-12 五 10:46] DEADLINE: <2019-07-12 五>
      即使值打印出来了, 但打印可能不准确, 甚至定位的语句也不准确
      - swgdb 用不了

***** TODO 与 x86 的数据进行对比
      DEADLINE: <2019-07-12 五 09:40>
      把错误的周围几个数据记录下来 :: 直接打印的输出可能位置不正确, 需要 gdb 
      x86 上的数据与<1>中的数据相同, 在 389-443 步异常, 对 i=389 进行调试输出, 记录 rc, x, exp_term
      记录 10 步的值, 测量误差
****** 最后一步 x 的值未输出

***** DONE 从 makefile 入手尝试
      CLOSED: [2019-07-12 五 08:53]
      

**** error2
***** 位置
     - 浮点 :: 424-553
***** 调试
     - 该步 S 无法打印
     - 将 S 中 exp 与 pow 分开计算 -- S1, S2 都正常打印, s1 过小, s2 正常 :: 二者的乘积导致异常
     - 将正常的 S 打印出来 :: 在乘积之后无法打印
     - 多进行一次 exp 可能影响性能, 但由于计算较复杂, 且 pauli 不是重点, 暂时直接判断
     - 科学计数法怎么表示 :: 字面常量
     - 找出最大可以正常运行的值 :: 267
     - 打印 S2 为何 S2 可以打印, 而其下一步却不行 :: test phase 可以打印
     - exp 之后的值无法判断, 就可以判断参数值
	       
**** double 的正确表示
     因为由于调试的操作可能使结果变得不准确
     错误的原因是因为, 较小的值可以存储, 但不能进行运算
     但错误的原因是不是可能是机器导致的值异常
**** 主核版本
    结果问题, 可能是第二个位置改得有问题 
***** 通过将三个机器中的值进行比较, 来找出结果信息, 
***** 加入纯主核版本
      DEADLINE: <2019-07-15 一 11:30>
*** 新平台的不同之处
     - 接口使用方法改变
     - makefile 修改
     - 在使用新内容同时需要引入(reduce)


*** TODO 主核 redo
   
**** DONE 第二处改完跑通
     CLOSED: [2019-07-15 一 14:44]
**** DONE 第一处异常
     CLOSED: [2019-07-15 一 14:49]
***** DONE 找出异常范围
      CLOSED: [2019-07-15 一 14:50]
**** TODO 进行结果比对
**** TODO 提交

*** 纯主核验证
    直接报错, 忽略

*** 结果比对方法
    - 在 th 上运行普通版本, 并给出结果
    - 再 th 上进行与新版相同的改进, 给出结果

*** TODO 从核移植
**** TODO makefile 为改动后
**** TODO eff 移植
     复制 eff, 改动 inline

*** TODO 性能
    
|      | cg |     1 |
|------+----+-------|
| none | 32 | 11:47 |
| cpe1 | 1  |  1:39 | 
|      |    |       |
从核这么快的原因时因为代码未运行!

*** TODO 从核版本
**** DONE 检查可运行 cg 数
     CLOSED: [2019-07-15 一 15:46] DEADLINE: <2019-07-15 一>
     单个一定能运行, 但多个时可能出现异常
**** TODO 验证从核代码运行
     DEADLINE: <2019-07-15 一 16:10>
     
***** TODO 错误分析
      数学库, inline 函数, 为何链接不到, 为何前面需要加 slave
      从核运行的外部函数需要加 slave, slave_只是一个形式吗, 只是表示其是从核调用的？[X]
      且只要这个函数在 CPE 内实现即可链接完成
      也就是说, 在编译时只是找到了定义, 而未完成链接
      在 CPE 内定义, 只会出现链接错误
      内外部的程序行为一致
      也就是说, 在 include 后程序只找到了定义, 而未找到实现, 这个是由 inline 导致的?
      但是数学库同样也有这样的现象
****** TODO 可能原因
       - 由于 inline 的格式引起
       - 只要时外部函数都会出现
       - makefile
       - sunway.h
       - inline 与 math 的上下依赖顺序不正确
       - inline 要放到根目录??
****** TODO 宏的区别
       - if 与 ifdef 在字面量存在与不存在分别的情况
	 - 只要未定义就一定不进入
	 - 定义
	   - ifdef 一定进入
	   - if 只在正确的时候进入
	 - 也就是说只要 if 可以进, ifdef 就一定能进

****** TODO 测试组
       - 去掉宏进行测试, 观察与结果是否一致
	 去掉宏出现错误
       - 最终结果可能是不进入导致的错误
       - _MYID 与 _PEN 的区别
******* TODO 去掉代码
	事实上无论有多少核组, 都有可能报错, 但这个问题可能是由于 ifdef 的问题
	导致代码未运行所致
******* TODO 原版打印
	代码未运行
******* TODO 加入测试函数
	运行
******* TODO 找到异常函数
	找不到数学函数

******* TODO 函数位置
	不是所有 inline 函数都找不到
	- 为什么 EEE 没问题, PEE 会出问题
	- ECE, PCPE, ECE

******* TODO 问题
	只编译前几个 PEE 是正常的, 但当数量多时就会报错

******* TODO 使用其他函数名替换
	可以, 此时与 PEE 函数唯一不同的就是函数内容
	与函数体无关
	删两个参数就正常了? 参数类型不对?
	加上参数又正常了?
	换个函数名又正常了?
	链接器??
	重新建一个项目再试试
	构建方式不对导致链接的时候找不到??
	再链接又找不到了
	还真是 inline 的问题??不是
	- PEE
	- PCPE
	- ierfover01
	先注释编译, 再正常编译
	注释后居然没编译
	改 inline 不会使从核部分重新编译
	当两个因素同时影响结果时, 就很难找出问题的所在
	

******* TODO 内联测试

***** 原因
      再编译时未加 lm_slave, 导致从核找不到数学库
      只改 inline 不会使从核文件重新编译
      inline 方法会使某些函数找不到(待解决)

**** 程序与结果
     值过大的原因是由于, 每个计算核都会对步骤运算一次, 导致值过大
***** 不同从核数量与结果

**** TODO 当前主核版本也不能保证正确性

**** TODO lj 从核结构
     DEADLINE: <2019-07-16 二 18:00>
     除 cache 无法使用, 其余均可以
***** TODO 主要改动部分
      - [ ] 数据分块
      - [ ] 数据传递
***** TODO 二者关系
      数据分块与传递是相互耦合的
***** TODO 过程
      - 对当前粒子进行分块
      - 首先传结构体
      - 传固定大小数组
      - jlist 与 jcache
      - 定义分块结构: 
	+ xi :: 每个 page 的 x
	+ fi :: 临时的 f(不需要传)
	+ ei :: eatom, 只在 tally 时遇到
	+ vi :: vatom, 同上
	+ v  :: 计算 ev_tally 的变量, 
	+ ti :: type
	+ fn :: firstneigh
	+ nn :: numneigh
	+ ipage_start
      - pagesize 定义

***** TODO 修改变量
      eng_virial :: 8 个 double
      - eng_vdwl
      - eng_coul
      - eng_virial
      - vatom :: 二者传回的时候直接传回该地址, 所以不需要额外操作
      - eatom

***** TODO 初版上的问题变量 :: 这个可能是速度拖慢速度的原因
      - cutsq 固定大小
      - virial, eatom, vatom 在初始化时赋 0 值后, 直接进行计算, 最后写回即可, 
      - vflag_fdotr_compute 不需要放到从核上计算
      - ev_tally_eff 考虑要不要展开
      - PAULI_CORE 是否是常量, 是就不需要直接传了
      - 所有的指针变量都可以用 get/put 进行传递, 有一些变量不需要传递
	+ [xi] x :: 先传递 x, 在分块后就立即传 x, 一次传一个 page 的 x, x 先从 pm 传, 还是从 l_pm 传
	+ [fi] f :: 临时创建
	+ [qi] q :: 按照 x 的方式进行传递            ---> 自有
	+ [si] spin :: 同上                        ---> 自有
	+ [ti] type :: 同上
	+ [ed] eradius :: 同上                     ---> 自有
	+ [cutsq] cutsq :: 固定大小
	+ [vi] vatom :: 创建传回
	+ [ei] eatom :: 同上
	+ [v] virial :: 同上, 值与 eng_virial 相关
	+ [ef] erforce :: 同 x                      ---> 自有
	+ pvector :: 创建传回??全局只有四个单位, 类似于 virial 的形式 ---> 自有
	+ [fn] firstneigh :: 同 type
	+ [nn] numneigh   :: 同 x
	+ [X] ilist      :: 直接利用分块代替
	+ [X] jlist      :: 通过 fn 传入
	原来的代码只是传回了 eng_virial, pvector, 且 pvector 可能不需要回传
***** TODO 统计需要写回的变量
      因为部分变量只是读入的

***** TODO 改动思路
      从处理过程向前看, 而不要直接看定义

***** TODO 两个模块区别
      - eff 不存在 mask

***** TODO 数据传递 step
      
****** DONE eng_virial
       CLOSED: [2019-07-16 二 20:35] DEADLINE: <2019-07-16 二 20:25>
       eng_virial 直接创建, 计算后直接传回.
       但在主核中需要指定, 以便回传时确定地址

****** DONE ntypes
       CLOSED: [2019-07-16 二 20:52]
       - 创建
       - put
       - use
	这个变量需要额外加入

****** DONE cutsq 
       CLOSED: [2019-07-16 二 20:52] DEADLINE: <2019-07-16 二 20:35>
       - 结构体创建
	 普通指针, 一维 pointer, 在创建时使用一维
       - 加入 pm
	 直接传
       - 传到 l_pm
	 一维转二维
****** TODO 定义分块变量 j
       DEADLINE: <2019-07-16 二 20：45>
       且需要定义常量

****** TODO 定义粒子分块变量
****** TODO  cache 的传递
       jlist_buf 保存 j 粒子号
       atom_in to j_cache
       将 j_cache, 传给 jlist_atom
       最后使用 jlist_atom 进行操作
       - 原来使用 xj 代替 jlist_atom, 且只有三个
       - fn -> jlist -> jlist_buf
       - 通过判断 jcache 的高位来判断, 需不需要传当前块, 如果相等则表通当前块已经传过, 否则需要传 n

******* TODO 结构大小
	- jlist_buf :: jpagesize
	- jlist_atom :: jpagesize
	- j_cache   :: [LINECNT][LINESIZE]
	- j_tag     :: LINECNT

****** TODO pvector
** TODO 从核代码的优化
*** TODO 计算的分布
**** TODO lj 中基本的分布操作
***** TODO 计算的分布的基本代码结构
****** TODO 从核的代码结构
******* TODO 基本函数
	-compute_a2s
******* TODO 基本数据结构
	- atom_in_t
	  原子的基本信息, 位置, 类型, sbj(与 sbmask 相关)
******* TODO 分布大小
	- 以 page 为单位, 大小为 128
	  - page 作用??
****** DONE lj 的基本计算
       CLOSED: [2019-07-11 四 9:12]
       - 以 compute()为主体, 存在多个不同类型(compute_inner/middle/outer)
	 三者功能类似, 但 inner/middle 在计算 force 之后就结束了
	 + 对各个原子进行迭代
	 + 对该原子的 neighbor 原子数进行迭代
	 + 判断原子间距离
	 + 计算 force 和 vdwl
****** DONE 从核函数的调用
       CLOSED: [2019-07-11 四 9:30]
       主核直接被调函数为 pair_lj_cut_compute(), 但事实上并没有调用到
****** TODO 从核函数的计算
       - init
       - 参数定义
       - 传 l_pm
       - 传 l_pm 中指针变量
       - 参数定义
       - 以 64 定义一个 ipage
       - 传变量
       - 在一个 page 中进行粒子迭代计算
       - 定义 jpage
       - 传参数
       - 计算
       - 回传
       - 主核 reduce

****** TODO 分块
       - ipage_start :: 从核单词处理开始的粒子号
	 - IPAGE_SIZE: 16
	 - JPAGE_SIZE: 64
	 - JLIST_SIZE: 256
	 - ILIST_PAGESIZE :: 每个 ILIST 单次应处理的粒子数
	 - JLIST_PAGESIZE: 64
       - 每次处理的粒子 i: 例如_MYID 为 0, 那么就从第 0 个开始, 一个从核每次处理 16 个粒
         子(在 eff 中也需要采取 16 吗), 每次递增 16*64 个
       - 每次粒子处理的编号从 start 到 end 即可, 单步递增
       - 单次处理的粒子 j: 与过程 i 基本相同, 不过是从 0 开始, 并且单次递增 256 个

****** 需要参照的部分
       对照 lj 的内容改动
       - i 与 j 如何划分
       - 都哪些部分进行了 put/get
******* TODO 与主核版关联
**** TODO tersoff 中的基本分布操作
***** TODO 分布的基本代码结构
****** TODO tersoff 的基本计算

*** TODO 向量化

** 版本
   - none :: git 第一次改动
   - pure :: 纯主核
   - cpe1  :: 接着 none 版本进行从核改动
 
** 拷数据
*** 内容
    主核, 
*** 主核更改内容
    异常修改, makefile, 主核不需要lm_slave
